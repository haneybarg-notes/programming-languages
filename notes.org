# -*- after-save-hook: org-latex-export-to-pdf; -*-
#+options: date:nil
#+language: bt-br
#+latex_header: \usepackage[a4paper, margin=2cm]{geometry}
#+latex_header: \usepackage{indentfirst}
#+latex_header: \usepackage[]{babel}
#+latex_header: \usepackage{float}
#+latex_header: \usepackage{color, colortbl}
#+latex_header: \usepackage{titling}
#+latex_header: \setlength{\droptitle}{-1.5cm}
#+latex_header: \hypersetup{ colorlinks = true, urlcolor = blue }
#+latex_header: \definecolor{beige}{rgb}{0.93,0.93,0.82}
#+latex_header: \definecolor{brown}{rgb}{0.4,0.2,0.0}


#+AUTHOR: Fernanda GuimarÃ£es
#+TITLE: Notes LP
* (05/08/19) What are programming languages?
  Programming languages are turing complete. Html is not a programming language. Assembly is.
  The formal definition is:
  - Syntax
  - Semantics
  -

  Words are easier to remember than numbers.

** Fortran
  IBM. It brought two news:
  - There are variables
  - Control structures (loops, conditionals).

  Parsing: read a chain of characters and transform it into a data structure (a tree).

** Lisp
  Paretheses.

  Based on mathematical functions and lists.

  News:  no need for parsing, built on linked lists.

** ALGOL
  Two news:
  - Type notation
  - Begin and end

** COBOL
   Grace Hopper.

   Looks like a natural language.

** How many are there?
   O'Reilly says that there are 2500, wikipedia says 650. Java is the most popular
   (portability).

*** Different purposes
    - Fortan: scientific calculus
    - Lisp: computer theory
    - COBOL: comercial applications
    - Algol: academic languages

** C
   Denis Reed

   It was made to finish UNIX.

   It's popular because the compiler already came with UNIX.

** PHP
   Recursive name.

   Useful for web servers.
   
   Came to supply the need for Pearl.

   Came with Apache, not efficient.

* (07/08/19) Types of languages
 State = memory
 
 Parsing = produce derivation trees for some chain of characters.

 A program in x86 is a set of instructions.

 Prolog isn't a patternized language.

** Imperatives (state)
   - C
   - Cpp
   - Java
   - Python
   - C# 
** Declaratives (stateless)
   There are no steps.
*** Functionals
    Lambda calculus.
    - ML
    - Haskell
    - Erlang
    - Elixir
    - Scala
*** Logicals
    Horn clause.
    - Prolog
    - Datalog
** Grammars
   - Tokens (terminals)
   - Non-terminals
   - Production rules
   - Start symbol
*** Types
    - Regulars: super fast.      
    - Context-free: can only have a symbol on the left side of production.
    - Context-sensitive: many symbols (right side is bigger or equal to left side).
    - Irrestricted grammar: Turing Machines.
* (12/08/19) Precedence
  Parsing is used in compilers, valgrind, static verification, etc.
  There are two semantics aspects of languages:
  - Associativity
  - Precedence
    
  In C, there are unary, binary and ternary operators. The closer to the roots, bigger the precedence
  
  At  tribution is associative to the right.
* (14/08/19) Compilation
  Search for: arithmetic identities of gcc.

  Programming languages are usually compiled (ex assembly), virtualized (ex python) or
  interpreted (ex bash).
  
  Virtualized are compiled to a virtual machine. 

** Why are some programs interpreted, others interpreted and others virtualized?
   Because of efficiency. It's better to compile the program when the execution time is
   really large.
** Compilation
   The classical Sequence:
   [editor] --> source file --> [preprocessor] --> preprocessed source file
   --> [compiler] --> assembly language file --> [assembler] -->
   object file --> [linker] --> executable file -->
   [loader] --> running program in memory
  
* (19/08/19) Introduction to ML
  Important: an algoritm that in C has less complexity than in ML.
  There isn't implicit coersion. Everything is explicit.

  Declarative Functional language. Follows the lambda-calculus. Program *is* a value, and
  not a sequence of state alterations. Every program in ML has a type. A bunch of
  functional languages have type inference.

  Built around /unification/.

  The five primitive types are: bool, int, real, char and string.

  You can't compare real and int, but you can convert one to another.

  Every if has an else, because every program is a value.

  Functions have a very high precedence.

** Tuples
   Tuples are indexed by 1. There are no one-element tuples.
   
   Every fun in ML receives only *one* parameter.
   
   Type contructor = '*'. It's like a fun that receives types and returns types. It's like
   generics in Java and templates in cpp.

** Lists
   Read head and read tail in O(1), same types.
  - [1,2,3];
  /val it = [1,2,3] : int list/
  - [1.0,2.0];
  /val it = [1.0,2.0] : real list/

  @ is O(n). :: is O(1) and associated to the right.

  /Explode/ splits a string into a list of chars.

  If the '$=$' operator appears in a definition of a fun, then real numbers cannot be used.
  
  You can force a fun to be real (it can come in several places):
  
    /fun prod(a,b):real = a * b;/

  The output of the type inference can be exponential.
* (21/08/19) Pattern matching in ML
  Undescores are better than a variable that is never going to be used.
  Two '' mean there are no real numbers.
* (26/08/19) Type
  Types are a set of values. Brainfuck and Forth don't have types. Type systems avoid some
  erros.
  
  Advantages: 
   - Documentation
   - Safety
   - Efficiency
   - Correctness

   In C, the size depends of the compiler. R is a language for array manipulation, so is
   matlab and APL.


** Primitive vs Constructed
   Primitive is built-in. Constructed types are just sets built from other sets.
   
   You can make constructed types by cartesian product, for example.

   In C, an enumeration is a subset of ints. Structs are stored sequentially.

   In Ml, you can only do a /comparison/ with an enumeration.

   The cardinality of a type is the product of its types cardinalities.

** Vectors
   Three abstractions: lists, vectors and strings.

   Vectors are a multidimensional cartesian product of the same set (same type).

** Union
   The cardinality is the /sum/ of the cardinality of its types. The space occupied is the
   largest element's size.
** Functions
   A map that maps the domain to a range. In C, you can pass a function as a parameters
   with a address.
** Static vs Dyamic Typing
   - Static examples: C, Java, /SML/, Cpp, Haskell.
   - Dynamic examples: Python, Javascript, Lisp, PHP, Ruby.

     Static are more efficient. Bigger programs tend to be written in statically typed
     languages. Are more legible.

     Dynamically typed typed languages are more reusable. This kind of reuse is called
     duck typing.

     
