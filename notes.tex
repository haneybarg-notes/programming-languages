% Created 2019-10-07 Mon 14:34
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage[a4paper, margin=2cm]{geometry}
\usepackage{indentfirst}
\usepackage[, brazilian]{babel}
\usepackage{float}
\usepackage{color, colortbl}
\usepackage{titling}
\setlength{\droptitle}{-1.5cm}
\hypersetup{ colorlinks = true, urlcolor = blue }
\definecolor{beige}{rgb}{0.93,0.93,0.82}
\definecolor{brown}{rgb}{0.4,0.2,0.0}
\author{Fernanda Guimarães}
\date{}
\title{Notes LP}
\hypersetup{
 pdfauthor={Fernanda Guimarães},
 pdftitle={Notes LP},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.1.9)}, 
 pdflang={Brazilian}}
\begin{document}

\maketitle
\section{(05/08/19) What are programming languages?}
\label{sec:orgcbd98bb}
Programming languages are turing complete. Html  is not a programming language. Assembly is.
The formal definition is:
\begin{itemize}
\item Syntax
\item Semantics
\item 
\end{itemize}

Words are easier to remember than numbers.

\subsection{Fortran}
\label{sec:org65116f9}
IBM. It brought two news:
\begin{itemize}
\item There are variables
\item Control structures (loops, conditionals).
\end{itemize}

Parsing: read a chain of characters and transform it into a data structure (a tree).

\subsection{Lisp}
\label{sec:org38448ff}
Paretheses.

Based on mathematical functions and lists.

News:  no need for parsing, built on linked lists.

\subsection{ALGOL}
\label{sec:orgf9e4094}
Two news:
\begin{itemize}
\item Type notation
\item Begin and end
\end{itemize}

\subsection{COBOL}
\label{sec:orgdb9fa11}
Grace Hopper.

Looks like a natural language.

\subsection{How many are there?}
\label{sec:orgad55d65}
O'Reilly says that there are 2500, wikipedia says 650. Java is the most popular
(portability).

\subsubsection{Different purposes}
\label{sec:org79f6129}
\begin{itemize}
\item Fortan: scientific calculus
\item Lisp: computer theory
\item COBOL: comercial applications
\item Algol: academic languages
\end{itemize}

\subsection{C}
\label{sec:orgf92e622}
Denis Reed

It was made to finish UNIX.

It's popular because the compiler already came with UNIX.

\subsection{PHP}
\label{sec:org4e87f8f}
Recursive name.

Useful for web servers.

Came to supply the need for Pearl.

Came with Apache, not efficient.

\section{(07/08/19) Types of languages}
\label{sec:orgb208552}
State = memory

Parsing = produce derivation trees for some chain of characters.

A program in x86 is a set of instructions.

Prolog isn't a patternized language. 

\subsection{Imperatives (state)}
\label{sec:orgfcf0aa1}
Turing machines.

\begin{itemize}
\item C
\item Cpp
\item Java
\item Python
\item C\#
\end{itemize}
\subsection{Declaratives (stateless)}
\label{sec:orga87ff4d}
There are no steps.
\subsubsection{Functionals}
\label{sec:org90d5ad3}
Lambda calculus.
\begin{itemize}
\item ML
\item Haskell
\item Lisp
\item Erlang
\item Elixir
\item Scala
\item Clojure
\end{itemize}
\subsubsection{Logicals}
\label{sec:orgad62f30}
Horn clause.
\begin{itemize}
\item Prolog
\item Datalog
\end{itemize}
\subsection{Grammars}
\label{sec:orgb4600d8}
\begin{itemize}
\item Tokens (terminals)
\item Non-terminals (variables)
\item Production rules
\item Start symbol
\end{itemize}
\subsubsection{Types}
\label{sec:org894f934}
\begin{itemize}
\item Regulars: super fast.
\item Context-free: can only have a symbol on the left side of production.
\item Context-sensitive: many symbols (right side is bigger or equal to left side).
\item Irrestricted grammar: Turing Machines.
\end{itemize}
\section{(12/08/19) Precedence}
\label{sec:org62408a3}
Parsing is used in compilers, valgrind, static verification, etc.
There are two semantics aspects of languages:
\begin{itemize}
\item Associativity
\item Precedence
\end{itemize}

In C, there are unary, binary and ternary operators. The closer to the roots, bigger the precedence.

Attribution is associative to the right.
\section{(14/08/19) Compilation}
\label{sec:org3cbff7f}
Search for: arithmetic identities of gcc.

Programming languages are usually compiled (ex assembly), virtualized (ex python) or
interpreted (ex bash).

Virtualized are compiled to a virtual machine.

\subsection{Why are some programs interpreted, others interpreted and others virtualized?}
\label{sec:org5bbfe62}
Because of efficiency. It's better to compile the program when the execution time is
really large.
\subsection{Compilation}
\label{sec:org2f7c06d}
The classical Sequence:
[editor] --> source file --> [preprocessor] --> preprocessed source file
--> [compiler] --> assembly language file --> [assembler] -->
object file --> [linker] --> executable file -->
[loader] --> running program in memory

\section{(19/08/19) Introduction to ML}
\label{sec:org7b1f4b5}
Important: an algoritm that in C has less complexity than in ML.
There isn't implicit coersion. Everything is explicit.

Declarative Functional language. Follows the lambda-calculus. Program \textbf{is} a value, and
not a sequence of state alterations. Every program in ML has a type. A bunch of
functional languages have type inference.

Built around \emph{unification}.

The five primitive types are: bool, int, real, char and string.

You can't compare real and int, but you can convert one to another.

Every if has an else, because every program is a value.

Functions have a very high precedence.

\subsection{Tuples: cartesian product}
\label{sec:org6d8305d}
Tuples are indexed by 1. There are no one-element tuples.

Every fun in ML receives only \textbf{one} parameter.

Type contructor = '*'. It's like a fun that receives types and returns types. It's like
generics in Java and templates in cpp.

\subsection{Lists}
\label{sec:org16cfb7f}
Read head and read tail in O(1), same types.
\begin{itemize}
\item\relax [1,2,3];
\end{itemize}
\emph{val it = [1,2,3] : int list}
\begin{itemize}
\item\relax [1.0,2.0];
\end{itemize}
\emph{val it = [1.0,2.0] : real list}

@ is O(n). :: is O(1) and associated to the right.

\emph{Explode} splits a string into a list of chars.

If the '\(=\)' operator appears in a definition of a fun, then real numbers cannot be used.

You can force a fun to be real (it can come in several places):

\emph{fun prod(a,b):real = a * b;}

The output of the type inference can be exponential.
\section{(21/08/19) Pattern matching in ML}
\label{sec:orgeb5c078}
Undescores are better than a variable that is never going to be used.
Two '' mean there are no real numbers.
\section{(26/08/19) Type}
\label{sec:orga2616d9}
Types are a set of values. Brainfuck and Forth don't have types. Type systems avoid some
erros.

Advantages:
\begin{itemize}
\item Documentation
\item Safety
\item Efficiency
\item Correctness
\end{itemize}

In C, the size depends of the compiler. R is a language for array manipulation, so is
matlab and APL.

\subsection{Primitive vs Constructed}
\label{sec:org25c5a45}
Primitive is built-in. Constructed types are just sets built from other sets.

You can make constructed types by cartesian product, for example.

In C, an enumeration is a subset of ints. Structs are stored sequentially.

In Ml, you can only do a \emph{comparison} with an enumeration.

The cardinality of a type is the product of its types cardinalities.

\subsection{Vectors}
\label{sec:orgf468e39}
Three abstractions: lists, vectors and strings.

Vectors are a multidimensional cartesian product of the same set (same type).

\subsection{Union}
\label{sec:org1570efc}
The cardinality is the \emph{sum} of the cardinality of its types. The space occupied is the
largest element's size.
\subsection{Functions}
\label{sec:orgcd5d6db}
A map that maps the domain to a range. In C, you can pass a function as a parameters
with a address.
\subsection{Static vs Dyamic Typing}
\label{sec:org491548a}
\begin{itemize}
\item Static examples: C, Java, \emph{SML}, Cpp, Haskell.
\item Dynamic examples: Python, Javascript, Lisp, PHP, Ruby.

Static are more efficient. Bigger programs tend to be written in statically typed
languages. Are more legible.

Dynamically typed typed languages are more reusable. This kind of reuse is called
duck typing.
\end{itemize}

\subsection{Strongly vs weakly typed}
\label{sec:org1ac9593}
A strongly typed language guarantees that a type will be always used as declared.

\begin{itemize}
\item Strongly: haskell, ml.
\item Weakly: c, cpp. Ex: unions, coersion, idexing. Advantage: performance.
\end{itemize}

\section{(28/08/19) Polymorfism}
\label{sec:org547bd22}
\subsection{Strategies to discover types}
\label{sec:org05e4c9f}
\begin{itemize}
\item Implicit: types are inferred.
\begin{itemize}
\item Inference: the compiler uses an algorithm that finds the correct type of
each value. Examples: Haskell, Scala, SML.
\item Special names: In some old languages, the name of the variable gives away
its type. Example: in old Fortran, integer variables should start with 'I'.
\end{itemize}
\item Explicit: syntax determines types.
\begin{itemize}
\item Annotations: the programmer must explicitly write the type of a symbol
next to it. Examples: Java, C, C++.
\end{itemize}
\end{itemize}

\subsection{Equivalence:}
\label{sec:orgb69d26d}
\begin{itemize}
\item name equivalence: two types are the same, if, and only if, they have the
same name: C, Java, C++, etc. Advantage: legibility.
\item structural equivalence: two types are the same if they have the same
structure. Example: SML. Advantage: reusability.
\end{itemize}

\subsection{Polymorfism}
\label{sec:orgec893ab}
Python is way more reusable than C or SML. The secret to get closer to Python is
polymorfism. A function or operator is \textbf{polymorphic} if it has at least two possible
types.

Which statically typed language gets closer to python? Two types of polymorfism:
\begin{itemize}
\item ad-hoc (infinite symbols)
\item universal
\end{itemize}
\subsubsection{Ad-hoc}
\label{sec:org6b992db}
\begin{itemize}
\item Overload. Uses the types to choose the definition.
\item Coersion. Uses the definition to choose a type conversion.
\end{itemize}
\begin{enumerate}
\item Overload:
\label{sec:orgda04c1a}
An overloaded function name or operator is one that has at least two definitions, all
of different types. Many languages have overloaded operators. There are languages
that allow the programmer to change the meaning of operators.

\item Coersion:
\label{sec:org3ab692b}
A coercion is an implicit type conversion, supplied automatically even if the
programmer leaves it out.
\end{enumerate}
\subsubsection{Universal}
\label{sec:orgde4efbf}
\begin{itemize}
\item Parametric
\item Subtyping
\end{itemize}
\begin{enumerate}
\item Subtyping:
\label{sec:orga59cccb}
Barbara Liskov's principle. Subtyping \textbf{isn't} the same as inheritance. Not the only
mecanism to create subptypes.
\end{enumerate}

\section{(02/09/19) Lambda calculus}
\label{sec:org1708ce1}
\subsection{Lambda expressions:}
\label{sec:orgc8125fb}

Each lambda declares a different name.

\begin{verbatim}
<expr> ::= <name>
      | \lambda <name> . <expr> |
      | <expr> <expr>           |

\end{verbatim}


\[(\lambda x \cdot x) \cdot w\], where


\begin{align*}     
  & x_0 = \text{formal parameter} \\
  & x_1 = \text{function body} \\
  & w   = \text{real parameters} \\
\end{align*}

\subsection{Numbers}
\label{sec:orgacef050}
A number is a function that takes a function s plus a constant z. The
number N is formed by applying s N times on z.
\begin{verbatim}
Zero = \s.\z.z
One = \s.\z.sz
Two = \s.\z.s(sz)
Three = \s.\z.s(s(sz))
\end{verbatim}
\section{(04/09/19) Currying and Higher order}
\label{sec:org9739644}
\subsection{Currying}
\label{sec:org2f6b866}
Then it is not possible to implement a function which take multiple parameters? Of
course, it is possible, by a methodology called currying.In currying every function
takes only one argument and returns a function. While the last function in this series
will return the desired output.

\subsection{Anonymous Functions}
\label{sec:orgfb1a436}
Starts with \emph{fn} (lambda functions). You can't do a recursive anonymous function because
it doesn't have a name. For you to do one, you need the \emph{y combinator}.

In SML, we can create anonymous functions, e.g: (fn x => x + 2) 3.

'fn' is the equivalent of lambdas in SML, e.g:
\x.x is equivalent to fn x => x

\begin{itemize}
\item val ZERO = fn s => fn z => z;
\item val ONE = fn s => fn z => s z;
\item val TWO = fn s => fn z => s (s z);
\item val THREE = fn s => fn z => s (s (s z));
\end{itemize}

\subsection{Higher Order}
\label{sec:org58c15b9}
Each function has an order:
\begin{itemize}
\item A function that does not take other functions as parameters, and does not return a
function value, has order 1
\item A function that takes a function as a parameter or returns a function value has order
n+1, where n is the order of its highest-order parameter or returned value
\end{itemize}
\begin{enumerate}
\item Foldr and Foldl
\label{sec:org7481e9e}
Only return the same when operators are both associative and commutative.
\end{enumerate}
\section{(11/09/19) Data Types/algebric types}
\label{sec:org97364f9}
\href{http://www.webber-labs.com/wp-content/uploads/2015/08/mpl-11.pdf}{Slides}
In C, the union is the closest to algebric types.

Data constructors :: Labels
Data Types :: constructors

\subsection{Datatype: union in ML}
\label{sec:org5f6c3c2}
New types can be defined using the keyword datatype.

These declarations define both:
– type constructors for making new (possibly
polymorphic) types
– data constructors for making values of those
new types 

We've seen two data structures: lists and tuples:

Lists = nil | e * Lists

In C, enumerations are like:

\begin{minted}[]{c}
#include <stdio.h>
enum Dia {Mon = 3, Tue, Wed, Thu, Fri, Sat, Sun};
int main () {
  printf("%d, %d, %d, %d, %d, %d, %d\n",
         Mon, Tue, Wed, Thu, Fri, Sat, Sun);
  printf("%d\n", Mon + Tue);
}   
\end{minted}

In ML:
\begin{minted}[]{sml}
datatype day = Mon | Tue | Wed | Thu | Fri | Sat | Sun;
fun isWeekDay x = if not (x = Sat orelse x = Sun) then true else false ;
isWeekDay Mon;
\end{minted}
\subsection{Extint (of)}
\label{sec:orgfc79974}
To recover a data constructor’s parameters, use pattern matching. You can't do the same
(pattern matching) with a function.
\subsection{Option - type constructors}
\label{sec:org04f71e4}
Is a polymorphic type. Used by predefined functions (or your own) when the result is
not always defined
\begin{minted}[]{sml}
datatype 'a option = NONE | SOME of 'a;
\end{minted}

\section{(19/09/19) Review}
\label{sec:org69fd3bd}
\begin{itemize}
\item Ocaml and subtyping
\item Types of languages
\item Elixir and Erlang are on the same VM
\item h::t
\item Context-free: can only have a symbol on the left side of production and produce 0 or
more things on the right side. Given a string, you can always say if a string belongs,
but can't determine wether it's ambiguous (can generate an infinite set of strings).
\begin{itemize}
\item Tokens (terminals)
\item Non-terminals (variables)
\item Production rules
\item Start symbol
\end{itemize}
\item \textbf{Serious}: need to write grammar in prolog (attributes and no attributes). Ex: count number of constants.
\item There are two semantics aspects of languages (for binary operators):
\begin{itemize}
\item Associativity: which operator to evaluate first (right or left).
\item Precedence
\end{itemize}
\item[{In ml,}] are associative to the right.
\item Turing Completes need loops.
\item Compile, interpret, and virtualize.
\item In Javascript, the browser gets the source code (no binary code). Not x86.
\item Java is ASCII, bytecodes is a binary language executed in a hw called JVM.
\item Scala, clojure, kotlin, groov: jvm.
\item Tuples and lists are the only structures (actually tuples only).
\item List operations
\item The pogram with polynoms doesn't fall in the test
\item The one with the triangles might
\item six patterns in ml: variables, constants, lists, tuples, nil, h
\item Types are a set of values. Brainfuck and Forth don't have types. Type systems avoid some
erros.
\item The cardinality of a type is the product of its types cardinalities.
\item Vectors are a multidimensional cartesian product of the same set (same type).
\item Tuples have different types
\item In ml, the union is the datatype.  The cardinality is the \emph{sum} of the cardinality of
its types. The space occupied is the largest element's size.
\item Cartesians, Vectors, functions and unions.
\item Static examples: C, Java, \emph{SML}, Cpp, Haskell.
\item Dynamic examples: Python, Javascript, Lisp, PHP, Ruby.
\item Static vs Dyamic, Strongly vs Weak, Nominal vs Structurual, Inference vs annotation. Advantages of each one.
\item Coersion is like converting.
\item Advantage of weakly typed: performance.
\item There's a spectrum of dynamic to static typing.
\item There is a if then else in m.() in java, for example.
\item Types of polymorfirsm
\item Polymorfistm is about statically typed languages. It's point is to get statically typed to be more reusable.
\item hd function in ml, e.g, is polymorfic.
\item differnce in universal and ad-hoc.
\item VAI CAIR OCAML e subtyping.
\item Watch out with renaming in lambda-calculus (avoid variable captures).
\item Operations with church number, you gotta know how to do. No succ
declaration. Implement add given succ. Convert church number to int.
\item Map, filter e fold.
\item Scope is a region where a symbol exists.
\item Almost every language is static scope.
\item \textbf{Bash} is the only dynamic que presta.
\item Two types of forming scope: blocks and namespaces.
\item A tree can be a tree or 2 elements plus a tree.
\item 
\end{itemize}
\section{(30/09/19) Memory allocation}
\label{sec:orgba0b6e3}
Operating System delivers to the program all adressing space.

Memory is organized in three parts by compiler:
\begin{enumerate}
\item Static (Cobol/Fortran)
\item Stack (Algol)
\item Heap (Lisp)
\end{enumerate}

\emph{Static} has the same functionality in \emph{C} and in \emph{Java}:

\begin{center}
Static \(==\) compile time
\end{center}

Consequence: only \textbf{one} (ALWAYS) instance of static variable, because its adress is known
in compile time.

\subsection{Static Memory}
\label{sec:org1ba2ac6}
\begin{enumerate}
\item Static
\item Global
\item Program
\item Strings
\end{enumerate}


Advantages: easy to program.

Disavantages: lose recursion (big) and [doubt].

\section{Dynamic Memory}
\label{sec:org09f2a16}
\subsection{Stack}
\label{sec:org4b101f9}
Program is usually in a contiguous memory area. Later there is an area that the compiler
uses during the program execution, called stack. Usually in C, you only get into a
function with a call and leave with a return. In python, Lua and ruby, there are yield
and generators. 

With a stack, I solve the recursion and cuncurrent allocation problem. Almost all
languages have a stack that grows top-down.

\subsection{Heap}
\label{sec:org6f3d26f}
Doesn't solve the OO problem nor the "good and evil".  In \emph{C}, the heap is used with a
malloc. in Python, everywhere. In java, with \emph{new}. In ML, \emph{clojures} stay in heap as well.
The data that live more than its functions live in the heap. In OOP, the heap is more
used (data is more important than functions).

\begin{itemize}
\item \textbf{What is malloc's complexity?} free is always O(1). Malloc is O(1) if called
alone. Malloc is online (non deterministic) if you call malloc and free
alternatively.
\end{itemize}

Garbage collector is only in \emph{heap}. There is no need for it in stack (just update a
pointer). Heap: allocation and free is out of order.

Two ways to do garbage collection:
\begin{enumerate}
\item Counter - problems: cycles (functional languages don't have this problem)
\item Tracing (marcação e varredura): all imperative languages like Java. Mark the
reachable space if memory is being used.
\end{enumerate}

\section{(07/10/19)}
\label{sec:org486b41e}
There is function and data (objects) orientation. Object O is a natural form to get
encapsulation. Object orientation is the data knowing how to do stuff.  Simula was the
first OO language. Smalltalk was later (more know).  Messages are methods today. It was
not common to put operations in tables.
\subsection{Language OO that don't have classes}
\label{sec:orgff27570}
\begin{itemize}
\item Lua
\item Javascript
\end{itemize}
\subsection{Feautres all OO}
\label{sec:org33c1bbe}
\begin{itemize}
\item have objects
\item have methods
\item heap
\item subtyping
\item Dynamic method invocation
\end{itemize}
\subsection{Some features in OO (not common to all)}
\label{sec:org305aeb0}
– Classes
– Prototypes
– Inheritance
– Encapsulation
– Polymorphism
\subsection{What is an object?}
\label{sec:org03781c4}
Object is data. It is a table. There are pointers to functions and to itself.
\subsection{Can you create obj without classes?}
\label{sec:orgdc20f1d}
Yes. Example python and scala (clojures).  
\subsection{What is inheritance?}
\label{sec:orgcc20643}
Reuse mechanism. In many lanuages like python and Java, inheritance is subtyping. Not
in haskell and Ocaml.
\subsection{Can you think about a situation in which we would like to have multiple inheritance?}
\label{sec:org55f615e}
Python and cpp have. Java doesn't. Few languages have multiple inheritance due to
ambiguity.
\subsection{What is the Liskov's substitution principle?}
\label{sec:org50ffa85}
If S is a subtype of T, then S can be used in any situation where T is expected.
\subsection{Methods in python and Java?}
\label{sec:org6c641c3}
\begin{itemize}
\item In python, with inheritance, the call is proportional to the tree size.
\item In Java, it is O(1).
\end{itemize}
\subsection{Dynamic method invocation}
\label{sec:org499bd49}
\begin{itemize}
\item O(1) call is only possible in statically typed languages. For python, the type and
adresses are only know in run time.
\end{itemize}
\subsection{What is the complexity to find the target of a call in Python?}
\label{sec:orgf5de3c5}
O(n).
\subsection{What about the complexity to find the target of a call in Java?}
\label{sec:org52eede1}
O(1).
\subsection{Top down vs bottom up}
\label{sec:org9a02a67}
\end{document}
